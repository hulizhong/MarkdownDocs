[toc]

## About c11

编译的时候
> g++ xx.cpp --std=[c\+\+11|c\+\+0x]

c\+\+03发布之后一直致力于发展下一版本国际标准。
最初设计的是07，但未完成，就叫了c\+\+0x。
直到10年才完成，所以最后叫了c\+\+11。


## enum class

```cpp
enum class Color {
	black,
	white,
	red
};
//添加了域访问符
Color c = Color::black;
```

程序只要能暴露错误在编译期间都是好消息，所以enum class的类型安全是值得推广使用的。


## 数值、字符串转换
### 字符串转数值
```cpp
std::aoti(const char *)  //字符串转换为int类型。
std::aotl(const char *)  //字符串转换为long类型。
std::aotll(const char *) //字符串转换为long long类型。
std::aotf(const char *)  //字符串转换为浮点类型。
```

### 数值转字符串
```cpp
std::string to_string(int value);
std::string to_string(long value);
std::string to_string(long long value);
std::string to_string(unsigned value);
std::string to_string(unsigned long value);
std::string to_string(unsigned long long value);
std::string to_string(float value);
std::string to_string(double value);
std::string to_string(long double value);
//以及它们的wstring版本
std::wstring to_wstring(int value);
```


### 宽窄字符串转换
C++11增加了unicode字面量的支持，可以通过L来定义宽字符。
宽字符串（std::wstring）窄字符串（std::string）间的转换需要用到codecvt库。
```cpp
std::wstring str = L"中国人"; //定义unicode字符串

#include <codecvt>
#include <string>

// convert UTF-8 string to wstring
std::wstring utf8_to_wstring (const std::string& str)
{
	std::wstring_convert<std::codecvt_utf8<wchar_t>> myconv;
	return myconv.from_bytes(str);
}

// convert wstring to UTF-8 string
std::string wstring_to_utf8 (const std::wstring& str)
{
	std::wstring_convert<std::codecvt_utf8<wchar_t>> myconv;
	return myconv.to_bytes(str);
}
```
**以上代码段在gcc4.x系列中会报错：fatal error: codecvt: No such file or directory**
主要是因为只有到gcc5才会完全支持c11的特性；
如果gcc版本不满足，那么可以用[boost的conv来实现](../boost/tools.md#转码)；（它也是跨平台的）


## smart ptr
为了解决C++内存泄漏的问题，C++11引入了智能指针（Smart Pointer）。

智能指针的原理是，接受一个申请好的内存地址，构造一个保存在栈上的智能指针对象，当程序退出栈的作用域范围后，由于栈上的变量自动被销毁，智能指针内部保存的内存也就被释放掉了（除非将智能指针保存起来）。

C++11提供了三种智能指针，使用时需添加头文件<memory>。
std::shared_ptr
std::unique_ptr
std::weak_ptr

