[toc]

## ReadMe
讲解c++11的知识点

http://blog.csdn.net/huliwei000/article/details/41869859

### About c11

编译的时候
> g++ xx.cpp --std=[c\+\+11|c\+\+0x]

c\+\+03发布之后一直致力于发展下一版本国际标准。
最初设计的是07，但未完成，就叫了c\+\+0x。
直到10年才完成，所以最后叫了c\+\+11。


## enum class

```cpp
enum class Color {
	black,
	white,
	red
};
//添加了域访问符
Color c = Color::black;
```

程序只要能暴露错误在编译期间都是好消息，所以enum class的类型安全是值得推广使用的。


## 数值、字符串转换
### 字符串转数值
```cpp
std::aoti(const char *)  //字符串转换为int类型。
std::aotl(const char *)  //字符串转换为long类型。
std::aotll(const char *) //字符串转换为long long类型。
std::aotf(const char *)  //字符串转换为浮点类型。
```

### 数值转字符串
```cpp
std::string to_string(int value);
std::string to_string(long value);
std::string to_string(long long value);
std::string to_string(unsigned value);
std::string to_string(unsigned long value);
std::string to_string(unsigned long long value);
std::string to_string(float value);
std::string to_string(double value);
std::string to_string(long double value);
//以及它们的wstring版本
std::wstring to_wstring(int value);
```


### 宽窄字符串转换
C++11增加了unicode字面量的支持，可以通过L来定义宽字符。
宽字符串（std::wstring）窄字符串（std::string）间的转换需要用到codecvt库。
```cpp
std::wstring str = L"中国人"; //定义unicode字符串

#include <codecvt>
#include <string>

// convert UTF-8 string to wstring
std::wstring utf8_to_wstring (const std::string& str)
{
	std::wstring_convert<std::codecvt_utf8<wchar_t>> myconv;
	return myconv.from_bytes(str);
}

// convert wstring to UTF-8 string
std::string wstring_to_utf8 (const std::wstring& str)
{
	std::wstring_convert<std::codecvt_utf8<wchar_t>> myconv;
	return myconv.to_bytes(str);
}
```
**以上代码段在gcc4.x系列中会报错：fatal error: codecvt: No such file or directory**
主要是因为只有到gcc5才会完全支持c11的特性；
如果gcc版本不满足，那么可以用[boost的conv来实现](../boost/tools.md#转码)；（它也是跨平台的）


## smart ptr
为了解决C++内存泄漏的问题，C++11引入了智能指针（Smart Pointer）。

智能指针的原理是，接受一个申请好的内存地址，构造一个保存在栈上的智能指针对象，当程序退出栈的作用域范围后，由于栈上的变量自动被销毁，智能指针内部保存的内存也就被释放掉了（除非将智能指针保存起来）。

C++11提供了三种智能指针，使用时需添加头文件<memory>。
std::shared_ptr
std::unique_ptr
std::weak_ptr

## 并发
### 线程创建
运行一个新线程,它带有一个函数对象参数和一系列可选的传递给函数对象的参数. 
```cpp
std::thread
```

### 异步线程
线程间传递异步结果
```cpp
futures
promises
std::packaged_task
```

### 线程同步
通过RAII锁和加锁算法
```cpp
std::mutex, std::recursive_mutex
std::condition_variable, std::condition_variable_any
```

### 原子操
为了高性能或底层工作,要求线程间的通信没有开销巨大的互斥锁.
```cpp
#include <atomic>
std::atomic<Type>
	//对int, char, bool等数据结构进行原子性封装，在多线程环境中，对std::atomic对象的访问不会造成竞争-冒险。
	//利用std::atomic可实现数据结构的无锁设计。

std::atomic_flag af = ATOMIC_FLAG_INIT;
	//std::atomic_flag可用于多线程之间的同步操作，类似于linux中的信号量。使用atomic_flag可实现mutex.
	//是一个原子的布尔类型，可支持test_and_set, clear两种原子操作：
af.test_and_set()
	//如果atomic_flag对象被设置，则返回true; 如果atomic_flag对象未被设置，则设置之，返回false
af.clear()
	//清除atomic_flag对象
```

