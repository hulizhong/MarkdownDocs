[TOC]

## ReadMe
讲解c++11的知识点

http://blog.csdn.net/huliwei000/article/details/41869859
https://blog.csdn.net/u010300403/article/details/78264719?locationNum=3&fps=1

- 容器 
	- array 定长数组，替代特定场景的std::vector使用
	- foword\_list 单向链表，性能比std::list高，但是使用限制多，特定情形可使用
	- unorderd\_set/multiset/map/multimap hash容器
		- 需要提供hash函数和等于判断函数，hash函数用于桶映射，等于函数用于解决hash碰撞问题。
	- emplace系列函数 – 性能优化
- Type\_traits：解决模板编程中类型相关的操作
	- std::is\_same<>
	- std::is\_abstract<>
	- std::is\_unsigned<>
	- std::is\_constructible<>
	- ...
- std::tuple：是std::pair的扩展，适用范围更广
	- std::make\_tuple
	- std::forward\_as\_tuple
	- std::tie
	- std::get<>
	- std::ignore


### About c11

编译的时候
> g++ xx.cpp --std=[c\+\+11|c\+\+0x]

c\+\+03发布之后一直致力于发展下一版本国际标准。
最初设计的是07，但未完成，就叫了c\+\+0x。
直到10年才完成，所以最后叫了c\+\+11。


## enum class

```cpp
enum class Color {
	black,
	white,
	red
};
//添加了域访问符
Color c = Color::black;
```

程序只要能暴露错误在编译期间都是好消息，所以enum class的类型安全是值得推广使用的。


## 数值、字符串转换
### 字符串转数值
```cpp
std::aoti(const char *)  //字符串转换为int类型。
std::aotl(const char *)  //字符串转换为long类型。
std::aotll(const char *) //字符串转换为long long类型。
std::aotf(const char *)  //字符串转换为浮点类型。
```

### 数值转字符串
```cpp
std::string to_string(int value);
std::string to_string(long value);
std::string to_string(long long value);
std::string to_string(unsigned value);
std::string to_string(unsigned long value);
std::string to_string(unsigned long long value);
std::string to_string(float value);
std::string to_string(double value);
std::string to_string(long double value);
//以及它们的wstring版本
std::wstring to_wstring(int value);
```


### 宽窄字符串转换
C++11增加了unicode字面量的支持，可以通过L来定义宽字符。
宽字符串（std::wstring）窄字符串（std::string）间的转换需要用到codecvt库。
```cpp
std::wstring str = L"中国人"; //定义unicode字符串

#include <codecvt>
#include <string>

// convert UTF-8 string to wstring
std::wstring utf8_to_wstring (const std::string& str)
{
	std::wstring_convert<std::codecvt_utf8<wchar_t>> myconv;
	return myconv.from_bytes(str);
}

// convert wstring to UTF-8 string
std::string wstring_to_utf8 (const std::wstring& str)
{
	std::wstring_convert<std::codecvt_utf8<wchar_t>> myconv;
	return myconv.to_bytes(str);
}
```
**以上代码段在gcc4.x系列中会报错：fatal error: codecvt: No such file or directory**
主要是因为只有到gcc5才会完全支持c11的特性；
如果gcc版本不满足，那么可以用[boost的conv来实现](../boost/tools.md#转码)；（它也是跨平台的）


## smart ptr
为了解决C++内存泄漏的问题，C++11引入了智能指针（Smart Pointer）。

智能指针的原理是，接受一个申请好的内存地址，构造一个保存在栈上的智能指针对象，当程序退出栈的作用域范围后，由于栈上的变量自动被销毁，智能指针内部保存的内存也就被释放掉了（除非将智能指针保存起来）。

C++11提供了三种智能指针，使用时需添加头文件<memory>。
std::shared_ptr
std::unique_ptr
std::weak_ptr

## 并发
[参考](#c11-thread.md)

## 其它
std::hash
```cpp
#include <functional>

std::hash<std::string> hash_fn;
size_t strhash = hash_fn("key");  //返回size_t, 即一个整数；
	//key1==key2，strhash1==strhash2;
	//key1!=key2, strhash1==strhash2的概率很小，大概接近1.0/std::numeric_limits<size_t>::max(). 
boost::lexical_cast<std::string>(str_hash);
```



```cpp
std::vector<int> getVec()
{    
    std::cout << "call onece." << std::endl;
    std::vector<int> vec;
    vec.push_back(1);
    vec.push_back(2);
    vec.push_back(3);
    return vec;
}    
     
int main()
{    
    for (auto it : getVec()) {  //函数调用只会发生一次！
        std::cout << it << std::endl;
    }
     
    std::vector<int> res;
    int i = 0;
    for (i=0, res=getVec(); i<res.size(); i++) { //函数调用只会发生一次！
        std::cout << res[i] << std::endl;
    }
     
    for (i=0; i<(res=getVec()).size(); i++) { //函数调用只会发生多次！
        std::cout << res[i] << std::endl;
    }
     
    return 0;
} 
```

