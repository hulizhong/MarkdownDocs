[TOC]

## ReadMe
讲解perl中的正则

## 匹配相关
包含如下
[修饰符](#修饰符)
[匹配结果](#匹配结果)
[中文匹配](#中文匹配)

### 修饰符
模式匹配有一些常用的修饰符，如下表所示：

|修饰符|描述|
|------|----|
|u |unicode|
|i |忽略模式中的大小写|
|m |多行模式，主要受影响是^$符号|
|o |仅赋值一次|
|s |单行模式，"."匹配"\n"（默认不匹配）|
|x |忽略模式中的空白|
|g |全局匹配。while循环中匹配一个正则，下次匹配从上一次匹配后的位置开始|
|cg |全局匹配失败后，允许再次查找匹配串|



### 匹配结果

|符号|描述|
|------|----|
|$` |前段|
|$& |匹配段|
|$' |后段|



### 中文匹配
用Encode来实现
```perl
#!/usr/bin/perl -w
use Encode;
my $txt = "hulg02fdsajk04\@staff.sina.com.cn;xx\@staff.sina.com.cn";
Encode::_utf8_on($txt); #这是关键，用uft8方式解释字符串；
my $rgx = qr/[-\w\x{4e00}-\x{9fa5}]{1,64}\@staff\.sina\.com\.cn/; 
while ($txt =~ /$rgx/ug) {
	print "<$&>\n";
}
```

## 匹配效率
具有更加确定性的正则会相对快点
```perl
^\s*[\w]{1-64}\(\)\s*{
^\s*function\s?[\w]{1-64}\(\)\s*{
	第2个正则快；（相对第1个更具有确定性）
```

不保存结果的获取
```perl
(?:)
	通常括号中匹配到的正则，是需要分配空间进行保存的；但?:就不会保存结果了；
```

贪婪（perl正则默认行为）、懒惰
```perl
贪婪模式的量词如下：
	{m,n}
	{m,}
	?  0到1
	*  任意个，0到多
	+  1到多
如果在贪婪量词后面加?，那么就会变成懒惰匹配；

aa.*?cc 匹配字符串aabbccbbcc
	贪婪（尽可能长）会匹配出aabbccbbcc
	懒惰（尽可能短）会匹配出aabbcc
ab.*?cc 匹配字符串aabbcc
	在贪婪量词后加了字符'?'
```

## 问题集

